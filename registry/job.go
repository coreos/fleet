package registry

import (
	"errors"
	"path"
	"strings"

	etcdErr "github.com/coreos/fleet/third_party/github.com/coreos/etcd/error"
	"github.com/coreos/fleet/third_party/github.com/coreos/go-etcd/etcd"
	log "github.com/coreos/fleet/third_party/github.com/golang/glog"

	"github.com/coreos/fleet/event"
	"github.com/coreos/fleet/job"
)

const (
	jobPrefix     = "/job/"
	payloadPrefix = "/payload/"
)

// List the jobs all Machines are scheduled to run
func (r *Registry) GetAllJobs() []job.Job {
	var jobs []job.Job

	key := path.Join(keyPrefix, jobPrefix)
	resp, err := r.etcd.Get(key, true, true)

	if err != nil {
		return jobs
	}

	for _, node := range resp.Node.Nodes {
		if j := r.GetJob(path.Base(node.Key)); j != nil {
			jobs = append(jobs, *j)
		}
	}

	return jobs
}

func (r *Registry) GetAllJobsByMachine(machBootID string) []job.Job {
	var jobs []job.Job

	key := path.Join(keyPrefix, jobPrefix)
	resp, err := r.etcd.Get(key, true, true)

	if err != nil {
		log.Errorf(err.Error())
		return jobs
	}

	for _, node := range resp.Node.Nodes {
		if j := r.GetJob(path.Base(node.Key)); j != nil {
			tgt := r.GetJobTarget(j.Name)
			if tgt != "" && tgt == machBootID {
				jobs = append(jobs, *j)
			}
		}
	}

	return jobs
}

// GetJobTarget looks up where the given job is scheduled. If the job has
// been scheduled, the boot ID the target machine is returned. Otherwise,
// an empty string is returned.
func (r *Registry) GetJobTarget(jobName string) string {
	// Figure out to which Machine this Job is scheduled
	key := jobTargetAgentPath(jobName)
	resp, err := r.etcd.Get(key, false, true)
	if err != nil {
		return ""
	}

	return resp.Node.Value
}

func (r *Registry) ClearJobTarget(jobName, bootID string) error {
	key := jobTargetAgentPath(jobName)
	_, err := r.etcd.CompareAndDelete(key, bootID, 0)
	return err
}

func (r *Registry) GetJob(jobName string) *job.Job {
	key := path.Join(keyPrefix, jobPrefix, jobName, "object")
	resp, err := r.etcd.Get(key, false, true)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var jm jobModel
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Node.Value, &jm)

	// TODO: This is temporary. It will be removed once we switch over to
	// hashed payloads.
	if jm.Payload == nil {
		return nil
	}

	j := job.NewJob(jm.Name, *(jm.Payload))
	j.PayloadState = r.getPayloadState(jm.Name)

	j.State = r.determineJobState(jm.Name)
	return j
}

type jobModel struct {
	Name    string
	Payload *job.JobPayload
}

func (r *Registry) createPayload(jp *job.JobPayload) error {
	key := path.Join(keyPrefix, payloadPrefix, jp.Name)
	json, _ := marshal(jp)
	_, err := r.etcd.Create(key, json, 0)
	return err
}

func (r *Registry) DestroyJob(jobName string) {
	key := path.Join(keyPrefix, jobPrefix, jobName)
	r.etcd.Delete(key, true)
	r.destroyPayload(jobName)
}

func (r *Registry) destroyPayload(payloadName string) {
	key := path.Join(keyPrefix, payloadPrefix, payloadName)
	r.etcd.Delete(key, false)
}

func (r *Registry) CreateJob(j *job.Job) (err error) {
	r.createPayload(&(j.Payload))

	key := path.Join(keyPrefix, jobPrefix, j.Name, "object")
	json, _ := marshal(j)

	_, err = r.etcd.Create(key, json, 0)
	if err != nil && err.(*etcd.EtcdError).ErrorCode == etcdErr.EcodeNodeExist {
		err = errors.New("job already exists")
	}

	return
}

func (r *Registry) GetJobTargetState(jobName string) *job.JobState {
	key := jobTargetStatePath(jobName)
	resp, err := r.etcd.Get(key, false, false)
	if err != nil {
		if err.(*etcd.EtcdError).ErrorCode != etcdErr.EcodeNodeExist {
			log.Errorf("Unable to determine target-state of Job(%s): %v", jobName, err)
		}
		return nil
	}

	return job.ParseJobState(resp.Node.Value)
}

func (r *Registry) SetJobTargetState(jobName string, state job.JobState) error {
	key := jobTargetStatePath(jobName)
	_, err := r.etcd.Set(key, string(state), 0)
	return err
}

func (es *EventStream) filterJobTargetStateChanges(resp *etcd.Response) *event.Event {
	if resp.Action != "set" {
		return nil
	}

	dir, baseName := path.Split(resp.Node.Key)
	if baseName != "target-state" {
		return nil
	}

	jobName := path.Base(strings.TrimSuffix(dir, "/"))

	ts := job.ParseJobState(resp.Node.Value)
	if ts == nil {
		return nil
	}

	cs := es.registry.determineJobState(jobName)
	if *cs == *ts {
		return nil
	}

	var cType string
	switch *cs {
	case job.JobStateInactive:
		if *ts == job.JobStateLoaded {
			cType = "CommandLoadJob"
		}
	case job.JobStateLoaded:
		if *ts == job.JobStateInactive {
			cType = "CommandUnloadJob"
		} else if *ts == job.JobStateLaunched {
			cType = "CommandStartJob"
		}
	case job.JobStateLaunched:
		if *ts == job.JobStateLoaded {
			cType = "CommandStopJob"
		}
	}

	if cType == "" {
		return nil
	}

	agent := es.registry.GetJobTarget(jobName)
	return &event.Event{cType, jobName, agent}
}

func (r *Registry) ScheduleJob(jobName string, machBootID string) error {
	key := jobTargetAgentPath(jobName)
	_, err := r.etcd.Create(key, machBootID, 0)
	return err
}

func (r *Registry) LockJob(jobName, context string) *TimedResourceMutex {
	return r.lockResource("job", jobName, context)
}

func filterEventJobScheduled(resp *etcd.Response) *event.Event {
	if resp.Action != "create" {
		return nil
	}

	dir, baseName := path.Split(resp.Node.Key)
	if baseName != "target" {
		return nil
	}

	jobName := path.Base(strings.TrimSuffix(dir, "/"))

	return &event.Event{"EventJobScheduled", jobName, resp.Node.Value}
}

func filterEventJobUnscheduled(resp *etcd.Response) *event.Event {
	if resp.Action != "delete" && resp.Action != "compareAndDelete" {
		return nil
	}

	dir, baseName := path.Split(resp.Node.Key)
	if baseName != "target" {
		return nil
	}

	if resp.PrevNode == nil {
		return nil
	}

	jobName := path.Base(strings.TrimSuffix(dir, "/"))
	return &event.Event{"EventJobUnscheduled", jobName, resp.PrevNode.Value}
}

func filterEventJobDestroyed(resp *etcd.Response) *event.Event {
	if resp.Action != "delete" {
		return nil
	}

	dir, jobName := path.Split(resp.Node.Key)
	dir = strings.TrimSuffix(dir, "/")
	dir, prefixName := path.Split(dir)

	if prefixName != "job" {
		return nil
	}

	return &event.Event{"EventJobDestroyed", jobName, nil}
}

func jobTargetAgentPath(jobName string) string {
	return path.Join(keyPrefix, jobPrefix, jobName, "target")
}

func jobTargetStatePath(jobName string) string {
	return path.Join(keyPrefix, jobPrefix, jobName, "target-state")
}
