// Code generated by protoc-gen-go.
// source: fleet.proto
// DO NOT EDIT!

/*
Package rpc is a generated protocol buffer package.

It is generated from these files:
	fleet.proto

It has these top-level messages:
	MachineProperties
	UpdatedState
	UnitStateFilter
	UnitFilter
	ScheduleUnitRequest
	UnscheduleUnitRequest
	SaveUnitStateRequest
	Heartbeat
	GenericReply
	Units
	UnitStates
	UnitState
	ScheduledUnits
	ScheduledUnit
	UnitName
	Unit
	MaybeUnit
	NotFound
	UnitFile
	UnitOption
*/
package rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TargetState int32

const (
	TargetState_INACTIVE TargetState = 0
	TargetState_LOADED   TargetState = 1
	TargetState_LAUNCHED TargetState = 2
)

var TargetState_name = map[int32]string{
	0: "INACTIVE",
	1: "LOADED",
	2: "LAUNCHED",
}
var TargetState_value = map[string]int32{
	"INACTIVE": 0,
	"LOADED":   1,
	"LAUNCHED": 2,
}

func (x TargetState) String() string {
	return proto.EnumName(TargetState_name, int32(x))
}

type MachineProperties struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *MachineProperties) Reset()         { *m = MachineProperties{} }
func (m *MachineProperties) String() string { return proto.CompactTextString(m) }
func (*MachineProperties) ProtoMessage()    {}

type UpdatedState struct {
	UnitIds []string `protobuf:"bytes,1,rep,name=unit_ids" json:"unit_ids,omitempty"`
}

func (m *UpdatedState) Reset()         { *m = UpdatedState{} }
func (m *UpdatedState) String() string { return proto.CompactTextString(m) }
func (*UpdatedState) ProtoMessage()    {}

type UnitStateFilter struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Hash        string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	LoadState   string `protobuf:"bytes,3,opt,name=load_state" json:"load_state,omitempty"`
	ActiveState string `protobuf:"bytes,4,opt,name=active_state" json:"active_state,omitempty"`
	SubState    string `protobuf:"bytes,5,opt,name=sub_state" json:"sub_state,omitempty"`
	Machine     string `protobuf:"bytes,6,opt,name=machine" json:"machine,omitempty"`
}

func (m *UnitStateFilter) Reset()         { *m = UnitStateFilter{} }
func (m *UnitStateFilter) String() string { return proto.CompactTextString(m) }
func (*UnitStateFilter) ProtoMessage()    {}

type UnitFilter struct {
	Name         string      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	CurrentState TargetState `protobuf:"varint,2,opt,name=current_state,enum=rpc.TargetState" json:"current_state,omitempty"`
	Machine      string      `protobuf:"bytes,3,opt,name=machine" json:"machine,omitempty"`
}

func (m *UnitFilter) Reset()         { *m = UnitFilter{} }
func (m *UnitFilter) String() string { return proto.CompactTextString(m) }
func (*UnitFilter) ProtoMessage()    {}

type ScheduleUnitRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Machine string `protobuf:"bytes,2,opt,name=machine" json:"machine,omitempty"`
}

func (m *ScheduleUnitRequest) Reset()         { *m = ScheduleUnitRequest{} }
func (m *ScheduleUnitRequest) String() string { return proto.CompactTextString(m) }
func (*ScheduleUnitRequest) ProtoMessage()    {}

type UnscheduleUnitRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Machine string `protobuf:"bytes,2,opt,name=machine" json:"machine,omitempty"`
}

func (m *UnscheduleUnitRequest) Reset()         { *m = UnscheduleUnitRequest{} }
func (m *UnscheduleUnitRequest) String() string { return proto.CompactTextString(m) }
func (*UnscheduleUnitRequest) ProtoMessage()    {}

type SaveUnitStateRequest struct {
	Name  string     `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	State *UnitState `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
	Ttl   int32      `protobuf:"varint,3,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *SaveUnitStateRequest) Reset()         { *m = SaveUnitStateRequest{} }
func (m *SaveUnitStateRequest) String() string { return proto.CompactTextString(m) }
func (*SaveUnitStateRequest) ProtoMessage()    {}

func (m *SaveUnitStateRequest) GetState() *UnitState {
	if m != nil {
		return m.State
	}
	return nil
}

type Heartbeat struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Machine string `protobuf:"bytes,2,opt,name=machine" json:"machine,omitempty"`
	Ttl     int32  `protobuf:"varint,3,opt,name=ttl" json:"ttl,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}

type GenericReply struct {
}

func (m *GenericReply) Reset()         { *m = GenericReply{} }
func (m *GenericReply) String() string { return proto.CompactTextString(m) }
func (*GenericReply) ProtoMessage()    {}

type Units struct {
	Units []*Unit `protobuf:"bytes,1,rep,name=units" json:"units,omitempty"`
}

func (m *Units) Reset()         { *m = Units{} }
func (m *Units) String() string { return proto.CompactTextString(m) }
func (*Units) ProtoMessage()    {}

func (m *Units) GetUnits() []*Unit {
	if m != nil {
		return m.Units
	}
	return nil
}

type UnitStates struct {
	UnitStates []*UnitState `protobuf:"bytes,1,rep,name=unit_states" json:"unit_states,omitempty"`
}

func (m *UnitStates) Reset()         { *m = UnitStates{} }
func (m *UnitStates) String() string { return proto.CompactTextString(m) }
func (*UnitStates) ProtoMessage()    {}

func (m *UnitStates) GetUnitStates() []*UnitState {
	if m != nil {
		return m.UnitStates
	}
	return nil
}

type UnitState struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Hash        string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	LoadState   string `protobuf:"bytes,3,opt,name=load_state" json:"load_state,omitempty"`
	ActiveState string `protobuf:"bytes,4,opt,name=active_state" json:"active_state,omitempty"`
	SubState    string `protobuf:"bytes,5,opt,name=sub_state" json:"sub_state,omitempty"`
	Machine     string `protobuf:"bytes,6,opt,name=machine" json:"machine,omitempty"`
}

func (m *UnitState) Reset()         { *m = UnitState{} }
func (m *UnitState) String() string { return proto.CompactTextString(m) }
func (*UnitState) ProtoMessage()    {}

type ScheduledUnits struct {
	Units []*ScheduledUnit `protobuf:"bytes,1,rep,name=units" json:"units,omitempty"`
}

func (m *ScheduledUnits) Reset()         { *m = ScheduledUnits{} }
func (m *ScheduledUnits) String() string { return proto.CompactTextString(m) }
func (*ScheduledUnits) ProtoMessage()    {}

func (m *ScheduledUnits) GetUnits() []*ScheduledUnit {
	if m != nil {
		return m.Units
	}
	return nil
}

type ScheduledUnit struct {
	Name    string      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	State   TargetState `protobuf:"varint,2,opt,name=state,enum=rpc.TargetState" json:"state,omitempty"`
	Machine string      `protobuf:"bytes,3,opt,name=machine" json:"machine,omitempty"`
}

func (m *ScheduledUnit) Reset()         { *m = ScheduledUnit{} }
func (m *ScheduledUnit) String() string { return proto.CompactTextString(m) }
func (*ScheduledUnit) ProtoMessage()    {}

type UnitName struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *UnitName) Reset()         { *m = UnitName{} }
func (m *UnitName) String() string { return proto.CompactTextString(m) }
func (*UnitName) ProtoMessage()    {}

type Unit struct {
	Name  string      `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Unit  *UnitFile   `protobuf:"bytes,2,opt,name=unit" json:"unit,omitempty"`
	State TargetState `protobuf:"varint,3,opt,name=state,enum=rpc.TargetState" json:"state,omitempty"`
}

func (m *Unit) Reset()         { *m = Unit{} }
func (m *Unit) String() string { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()    {}

func (m *Unit) GetUnit() *UnitFile {
	if m != nil {
		return m.Unit
	}
	return nil
}

type MaybeUnit struct {
	// Types that are valid to be assigned to HasUnit:
	//	*MaybeUnit_Unit
	//	*MaybeUnit_Notfound
	HasUnit isMaybeUnit_HasUnit `protobuf_oneof:"has_unit"`
}

func (m *MaybeUnit) Reset()         { *m = MaybeUnit{} }
func (m *MaybeUnit) String() string { return proto.CompactTextString(m) }
func (*MaybeUnit) ProtoMessage()    {}

type isMaybeUnit_HasUnit interface {
	isMaybeUnit_HasUnit()
}

type MaybeUnit_Unit struct {
	Unit *Unit `protobuf:"bytes,1,opt,name=unit,oneof"`
}
type MaybeUnit_Notfound struct {
	Notfound *NotFound `protobuf:"bytes,2,opt,name=notfound,oneof"`
}

func (*MaybeUnit_Unit) isMaybeUnit_HasUnit()     {}
func (*MaybeUnit_Notfound) isMaybeUnit_HasUnit() {}

func (m *MaybeUnit) GetHasUnit() isMaybeUnit_HasUnit {
	if m != nil {
		return m.HasUnit
	}
	return nil
}

func (m *MaybeUnit) GetUnit() *Unit {
	if x, ok := m.GetHasUnit().(*MaybeUnit_Unit); ok {
		return x.Unit
	}
	return nil
}

func (m *MaybeUnit) GetNotfound() *NotFound {
	if x, ok := m.GetHasUnit().(*MaybeUnit_Notfound); ok {
		return x.Notfound
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MaybeUnit) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), []interface{}) {
	return _MaybeUnit_OneofMarshaler, _MaybeUnit_OneofUnmarshaler, []interface{}{
		(*MaybeUnit_Unit)(nil),
		(*MaybeUnit_Notfound)(nil),
	}
}

func _MaybeUnit_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MaybeUnit)
	// has_unit
	switch x := m.HasUnit.(type) {
	case *MaybeUnit_Unit:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Unit); err != nil {
			return err
		}
	case *MaybeUnit_Notfound:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Notfound); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MaybeUnit.HasUnit has unexpected type %T", x)
	}
	return nil
}

func _MaybeUnit_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MaybeUnit)
	switch tag {
	case 1: // has_unit.unit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Unit)
		err := b.DecodeMessage(msg)
		m.HasUnit = &MaybeUnit_Unit{msg}
		return true, err
	case 2: // has_unit.notfound
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NotFound)
		err := b.DecodeMessage(msg)
		m.HasUnit = &MaybeUnit_Notfound{msg}
		return true, err
	default:
		return false, nil
	}
}

type NotFound struct {
}

func (m *NotFound) Reset()         { *m = NotFound{} }
func (m *NotFound) String() string { return proto.CompactTextString(m) }
func (*NotFound) ProtoMessage()    {}

type UnitFile struct {
	UnitOptions []*UnitOption `protobuf:"bytes,1,rep,name=unit_options" json:"unit_options,omitempty"`
}

func (m *UnitFile) Reset()         { *m = UnitFile{} }
func (m *UnitFile) String() string { return proto.CompactTextString(m) }
func (*UnitFile) ProtoMessage()    {}

func (m *UnitFile) GetUnitOptions() []*UnitOption {
	if m != nil {
		return m.UnitOptions
	}
	return nil
}

type UnitOption struct {
	Section string `protobuf:"bytes,1,opt,name=section" json:"section,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Value   string `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *UnitOption) Reset()         { *m = UnitOption{} }
func (m *UnitOption) String() string { return proto.CompactTextString(m) }
func (*UnitOption) ProtoMessage()    {}

func init() {
	proto.RegisterType((*MachineProperties)(nil), "rpc.MachineProperties")
	proto.RegisterType((*UpdatedState)(nil), "rpc.UpdatedState")
	proto.RegisterType((*UnitStateFilter)(nil), "rpc.UnitStateFilter")
	proto.RegisterType((*UnitFilter)(nil), "rpc.UnitFilter")
	proto.RegisterType((*ScheduleUnitRequest)(nil), "rpc.ScheduleUnitRequest")
	proto.RegisterType((*UnscheduleUnitRequest)(nil), "rpc.UnscheduleUnitRequest")
	proto.RegisterType((*SaveUnitStateRequest)(nil), "rpc.SaveUnitStateRequest")
	proto.RegisterType((*Heartbeat)(nil), "rpc.Heartbeat")
	proto.RegisterType((*GenericReply)(nil), "rpc.GenericReply")
	proto.RegisterType((*Units)(nil), "rpc.Units")
	proto.RegisterType((*UnitStates)(nil), "rpc.UnitStates")
	proto.RegisterType((*UnitState)(nil), "rpc.UnitState")
	proto.RegisterType((*ScheduledUnits)(nil), "rpc.ScheduledUnits")
	proto.RegisterType((*ScheduledUnit)(nil), "rpc.ScheduledUnit")
	proto.RegisterType((*UnitName)(nil), "rpc.UnitName")
	proto.RegisterType((*Unit)(nil), "rpc.Unit")
	proto.RegisterType((*MaybeUnit)(nil), "rpc.MaybeUnit")
	proto.RegisterType((*NotFound)(nil), "rpc.NotFound")
	proto.RegisterType((*UnitFile)(nil), "rpc.UnitFile")
	proto.RegisterType((*UnitOption)(nil), "rpc.UnitOption")
	proto.RegisterEnum("rpc.TargetState", TargetState_name, TargetState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Registry service

type RegistryClient interface {
	// agents should request only the locally scheduled jobs
	GetScheduledUnits(ctx context.Context, in *UnitFilter, opts ...grpc.CallOption) (*ScheduledUnits, error)
	// should _never_ be used? fleetctl only ?
	GetScheduledUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*ScheduledUnit, error)
	// should _never_ be used ?
	GetUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*MaybeUnit, error)
	GetUnits(ctx context.Context, in *UnitFilter, opts ...grpc.CallOption) (*Units, error)
	// global status <= pretty much like list-unit-files
	GetUnitStates(ctx context.Context, in *UnitStateFilter, opts ...grpc.CallOption) (*UnitStates, error)
	ClearUnitHeartbeat(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error)
	CreateUnit(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*GenericReply, error)
	DestroyUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error)
	UnitHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*GenericReply, error)
	// mix heartbeat with *ttl''
	RemoveUnitState(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error)
	SaveUnitState(ctx context.Context, in *SaveUnitStateRequest, opts ...grpc.CallOption) (*GenericReply, error)
	ScheduleUnit(ctx context.Context, in *ScheduleUnitRequest, opts ...grpc.CallOption) (*GenericReply, error)
	SetUnitTargetState(ctx context.Context, in *ScheduledUnit, opts ...grpc.CallOption) (*GenericReply, error)
	UnscheduleUnit(ctx context.Context, in *UnscheduleUnitRequest, opts ...grpc.CallOption) (*GenericReply, error)
	AgentEvents(ctx context.Context, in *MachineProperties, opts ...grpc.CallOption) (Registry_AgentEventsClient, error)
}

type registryClient struct {
	cc *grpc.ClientConn
}

func NewRegistryClient(cc *grpc.ClientConn) RegistryClient {
	return &registryClient{cc}
}

func (c *registryClient) GetScheduledUnits(ctx context.Context, in *UnitFilter, opts ...grpc.CallOption) (*ScheduledUnits, error) {
	out := new(ScheduledUnits)
	err := grpc.Invoke(ctx, "/rpc.Registry/GetScheduledUnits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetScheduledUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*ScheduledUnit, error) {
	out := new(ScheduledUnit)
	err := grpc.Invoke(ctx, "/rpc.Registry/GetScheduledUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*MaybeUnit, error) {
	out := new(MaybeUnit)
	err := grpc.Invoke(ctx, "/rpc.Registry/GetUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetUnits(ctx context.Context, in *UnitFilter, opts ...grpc.CallOption) (*Units, error) {
	out := new(Units)
	err := grpc.Invoke(ctx, "/rpc.Registry/GetUnits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetUnitStates(ctx context.Context, in *UnitStateFilter, opts ...grpc.CallOption) (*UnitStates, error) {
	out := new(UnitStates)
	err := grpc.Invoke(ctx, "/rpc.Registry/GetUnitStates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ClearUnitHeartbeat(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/ClearUnitHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) CreateUnit(ctx context.Context, in *Unit, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/CreateUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) DestroyUnit(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/DestroyUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) UnitHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/UnitHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) RemoveUnitState(ctx context.Context, in *UnitName, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/RemoveUnitState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) SaveUnitState(ctx context.Context, in *SaveUnitStateRequest, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/SaveUnitState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ScheduleUnit(ctx context.Context, in *ScheduleUnitRequest, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/ScheduleUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) SetUnitTargetState(ctx context.Context, in *ScheduledUnit, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/SetUnitTargetState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) UnscheduleUnit(ctx context.Context, in *UnscheduleUnitRequest, opts ...grpc.CallOption) (*GenericReply, error) {
	out := new(GenericReply)
	err := grpc.Invoke(ctx, "/rpc.Registry/UnscheduleUnit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) AgentEvents(ctx context.Context, in *MachineProperties, opts ...grpc.CallOption) (Registry_AgentEventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Registry_serviceDesc.Streams[0], c.cc, "/rpc.Registry/AgentEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &registryAgentEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Registry_AgentEventsClient interface {
	Recv() (*UpdatedState, error)
	grpc.ClientStream
}

type registryAgentEventsClient struct {
	grpc.ClientStream
}

func (x *registryAgentEventsClient) Recv() (*UpdatedState, error) {
	m := new(UpdatedState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Registry service

type RegistryServer interface {
	// agents should request only the locally scheduled jobs
	GetScheduledUnits(context.Context, *UnitFilter) (*ScheduledUnits, error)
	// should _never_ be used? fleetctl only ?
	GetScheduledUnit(context.Context, *UnitName) (*ScheduledUnit, error)
	// should _never_ be used ?
	GetUnit(context.Context, *UnitName) (*MaybeUnit, error)
	GetUnits(context.Context, *UnitFilter) (*Units, error)
	// global status <= pretty much like list-unit-files
	GetUnitStates(context.Context, *UnitStateFilter) (*UnitStates, error)
	ClearUnitHeartbeat(context.Context, *UnitName) (*GenericReply, error)
	CreateUnit(context.Context, *Unit) (*GenericReply, error)
	DestroyUnit(context.Context, *UnitName) (*GenericReply, error)
	UnitHeartbeat(context.Context, *Heartbeat) (*GenericReply, error)
	// mix heartbeat with *ttl''
	RemoveUnitState(context.Context, *UnitName) (*GenericReply, error)
	SaveUnitState(context.Context, *SaveUnitStateRequest) (*GenericReply, error)
	ScheduleUnit(context.Context, *ScheduleUnitRequest) (*GenericReply, error)
	SetUnitTargetState(context.Context, *ScheduledUnit) (*GenericReply, error)
	UnscheduleUnit(context.Context, *UnscheduleUnitRequest) (*GenericReply, error)
	AgentEvents(*MachineProperties, Registry_AgentEventsServer) error
}

func RegisterRegistryServer(s *grpc.Server, srv RegistryServer) {
	s.RegisterService(&_Registry_serviceDesc, srv)
}

func _Registry_GetScheduledUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).GetScheduledUnits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_GetScheduledUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitName)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).GetScheduledUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_GetUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitName)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).GetUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_GetUnits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).GetUnits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_GetUnitStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitStateFilter)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).GetUnitStates(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_ClearUnitHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitName)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).ClearUnitHeartbeat(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_CreateUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Unit)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).CreateUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_DestroyUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitName)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).DestroyUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_UnitHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).UnitHeartbeat(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_RemoveUnitState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnitName)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).RemoveUnitState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_SaveUnitState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(SaveUnitStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).SaveUnitState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_ScheduleUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ScheduleUnitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).ScheduleUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_SetUnitTargetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ScheduledUnit)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).SetUnitTargetState(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_UnscheduleUnit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(UnscheduleUnitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(RegistryServer).UnscheduleUnit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Registry_AgentEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MachineProperties)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RegistryServer).AgentEvents(m, &registryAgentEventsServer{stream})
}

type Registry_AgentEventsServer interface {
	Send(*UpdatedState) error
	grpc.ServerStream
}

type registryAgentEventsServer struct {
	grpc.ServerStream
}

func (x *registryAgentEventsServer) Send(m *UpdatedState) error {
	return x.ServerStream.SendMsg(m)
}

var _Registry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "rpc.Registry",
	HandlerType: (*RegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetScheduledUnits",
			Handler:    _Registry_GetScheduledUnits_Handler,
		},
		{
			MethodName: "GetScheduledUnit",
			Handler:    _Registry_GetScheduledUnit_Handler,
		},
		{
			MethodName: "GetUnit",
			Handler:    _Registry_GetUnit_Handler,
		},
		{
			MethodName: "GetUnits",
			Handler:    _Registry_GetUnits_Handler,
		},
		{
			MethodName: "GetUnitStates",
			Handler:    _Registry_GetUnitStates_Handler,
		},
		{
			MethodName: "ClearUnitHeartbeat",
			Handler:    _Registry_ClearUnitHeartbeat_Handler,
		},
		{
			MethodName: "CreateUnit",
			Handler:    _Registry_CreateUnit_Handler,
		},
		{
			MethodName: "DestroyUnit",
			Handler:    _Registry_DestroyUnit_Handler,
		},
		{
			MethodName: "UnitHeartbeat",
			Handler:    _Registry_UnitHeartbeat_Handler,
		},
		{
			MethodName: "RemoveUnitState",
			Handler:    _Registry_RemoveUnitState_Handler,
		},
		{
			MethodName: "SaveUnitState",
			Handler:    _Registry_SaveUnitState_Handler,
		},
		{
			MethodName: "ScheduleUnit",
			Handler:    _Registry_ScheduleUnit_Handler,
		},
		{
			MethodName: "SetUnitTargetState",
			Handler:    _Registry_SetUnitTargetState_Handler,
		},
		{
			MethodName: "UnscheduleUnit",
			Handler:    _Registry_UnscheduleUnit_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AgentEvents",
			Handler:       _Registry_AgentEvents_Handler,
			ServerStreams: true,
		},
	},
}
